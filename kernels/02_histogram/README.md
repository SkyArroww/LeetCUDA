# 直方图统计 (Histogram)

## 0x00 算法原理

直方图统计是统计数组中每个元素出现次数的经典算法。给定输入数组 `a[N]`，输出计数数组 `y[M+1]`，其中 `y[i]` 表示值为 `i` 的元素在输入数组中出现的次数。

### 数学表示
```
输入: a[0...N-1], 其中 a[i] ∈ [0, M]
输出: y[0...M], 其中 y[i] = count(a[j] == i for all j)
```

## 0x01 实现版本

包含以下内容：

- [X] histogram_i32_kernel (基础版本)
- [X] histogram_i32x4_kernel (int4向量化版本)
- [X] PyTorch bindings

### 基础版本 (histogram_i32_kernel)

```cuda
__global__ void histogram_i32_kernel(int *a, int *y, int N) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (idx < N)
    atomicAdd(&(y[a[idx]]), 1);
}
```

**特点：**
- 每个线程处理一个元素
- 使用 `atomicAdd` 确保线程安全
- 内存访问：每个线程读取一个输入元素，写入对应的计数位置

### 向量化版本 (histogram_i32x4_kernel)

```cuda
__global__ void histogram_i32x4_kernel(int *a, int *y, int N) {
  int idx = 4 * (blockIdx.x * blockDim.x + threadIdx.x);
  if (idx < N) {
    int4 reg_a = INT4(a[idx]);
    atomicAdd(&(y[reg_a.x]), 1);
    atomicAdd(&(y[reg_a.y]), 1);
    atomicAdd(&(y[reg_a.z]), 1);
    atomicAdd(&(y[reg_a.w]), 1);
  }
}
```

**特点：**
- 每个线程处理4个元素（使用 `int4` 向量化）
- 减少线程数量，提高内存带宽利用率
- 内存合并访问：4个连续元素一次性读取

## 0x02 性能优化策略

### 1. 向量化优化
- **目标**：减少线程数量，提高内存带宽利用率
- **实现**：使用 `int4` 数据类型，每个线程处理4个元素
- **效果**：理论上可以减少75%的线程数量

### 2. 原子操作优化
- **必要性**：多线程环境下确保计数正确性
- **实现**：使用 `atomicAdd` 进行原子累加
- **注意**：原子操作可能成为性能瓶颈

### 3. 内存访问优化
- **合并访问**：向量化版本中4个元素连续存储
- **缓存友好**：减少内存事务数量
- **带宽利用**：提高内存带宽利用率

## 0x03 性能瓶颈分析

### 1. 原子操作冲突
- **问题**：多个线程同时访问同一计数位置时产生冲突
- **影响**：降低并行效率，增加延迟
- **缓解**：数据分布越均匀，冲突越少

### 2. 内存带宽限制
- **问题**：大量随机写入操作影响内存带宽
- **影响**：特别是当计数数组较大时
- **优化**：向量化可以减少内存事务数量

### 3. 负载均衡
- **问题**：输入数据分布不均匀时产生热点
- **影响**：某些计数位置访问频繁，其他位置访问较少
- **解决**：需要根据数据分布特征进行优化

## 0x04 使用场景

1. **数据统计分析**：统计数组中各元素的分布情况
2. **图像处理**：计算图像像素值的直方图
3. **机器学习**：特征工程中的数据分布分析
4. **数据库查询**：统计查询结果中各值的出现次数

## 0x05 测试

```bash
# 只测试Ada架构 不指定默认编译所有架构 耗时较长: Volta, Ampere, Ada, Hopper, ...
export TORCH_CUDA_ARCH_LIST=Ada
python3 histogram.py
```

输出:

```bash
--------------------------------------------------------------------------------
h_i32   0: 1000
h_i32   1: 1000
h_i32   2: 1000
h_i32   3: 1000
h_i32   4: 1000
h_i32   5: 1000
h_i32   6: 1000
h_i32   7: 1000
h_i32   8: 1000
h_i32   9: 1000
--------------------------------------------------------------------------------
h_i32x4 0: 1000
h_i32x4 1: 1000
h_i32x4 2: 1000
h_i32x4 3: 1000
h_i32x4 4: 1000
h_i32x4 5: 1000
h_i32x4 6: 1000
h_i32x4 7: 1000
h_i32x4 8: 1000
h_i32x4 9: 1000
--------------------------------------------------------------------------------
```

## 0x06 进一步优化方向

1. **分块处理**：将输入数据分块，减少原子操作冲突
2. **共享内存优化**：使用共享内存进行局部统计，减少全局内存访问
3. **多级直方图**：对于大数据集，使用多级直方图减少内存占用
4. **自适应向量化**：根据数据分布特征动态选择向量化程度
